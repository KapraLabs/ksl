// ksl_compiler.rs
// Compiles type-checked KSL AST into KapraBytecode 2.0.

use crate::ksl_parser::{AstNode, ExprKind, TypeAnnotation};
use crate::ksl_types::{Type, TypeContext, TypeSystem};
use crate::ksl_bytecode::{KapraBytecode, KapraInstruction, KapraOpCode, Operand};
use crate::ksl_stdlib::StdLib;
use crate::ksl_stdlib_crypto::CryptoStdLib;
use crate::ksl_macros::{MacroExpander, MacroDef};
use crate::ksl_generics::{GenericCompiler, GenericDef, TypeParam};
use std::collections::HashMap;

// Re-export dependencies
mod ksl_parser {
    pub use super::{AstNode, ExprKind, TypeAnnotation};
}

mod ksl_types {
    pub use super::{Type, TypeContext, TypeSystem};
}

mod ksl_bytecode {
    pub use super::{KapraBytecode, KapraInstruction, KapraOpCode, Operand};
}

mod ksl_stdlib {
    pub use super::StdLib;
}

mod ksl_stdlib_crypto {
    pub use super::CryptoStdLib;
}

mod ksl_macros {
    pub use super::{MacroExpander, MacroDef};
}

mod ksl_generics {
    pub use super::{GenericCompiler, GenericDef, TypeParam};
}

/// Compilation error type.
#[derive(Debug, PartialEq)]
pub struct CompileError {
    pub message: String,
    pub position: usize,
}

/// Compiler state for generating KapraBytecode.
pub struct Compiler {
    bytecode: KapraBytecode, // Generated bytecode
    registers: HashMap<String, u8>, // Variable name to register mapping
    next_register: u8, // Next free register (0â€“15)
    functions: HashMap<String, u32>, // Function name to instruction index
    labels: Vec<u32>, // Jump labels for control flow
    ctx: TypeContext, // Type context for type-safe codegen
    stdlib: StdLib, // Standard library functions
    crypto_stdlib: CryptoStdLib, // Cryptographic standard library functions
    macro_expander: MacroExpander, // Macro definitions and expansion
    generic_compiler: GenericCompiler, // Generic type compilation
    errors: Vec<CompileError>, // Collect compilation errors
}

impl Compiler {
    /// Creates a new compiler instance.
    /// @returns A new `Compiler` instance.
    /// @example
    /// ```ksl
    /// let compiler = Compiler::new();
    /// ```
    pub fn new() -> Self {
        Compiler {
            bytecode: KapraBytecode::new(),
            registers: HashMap::new(),
            next_register: 0,
            functions: HashMap::new(),
            labels: Vec::new(),
            ctx: TypeContext::new(),
            stdlib: StdLib::new(),
            crypto_stdlib: CryptoStdLib::new(),
            macro_expander: MacroExpander::new(),
            generic_compiler: GenericCompiler,
            errors: Vec::new(),
        }
    }

    /// Compiles an AST into bytecode.
    /// @param nodes The list of AST nodes to compile.
    /// @returns `Ok(KapraBytecode)` if compilation succeeds, or `Err` with compilation errors.
    /// @example
    /// ```ksl
    /// let nodes = vec![AstNode::VarDecl { ... }];
    /// let bytecode = compiler.compile(&nodes).unwrap();
    /// ```
    pub fn compile(&mut self, nodes: &[AstNode]) -> Result<KapraBytecode, Vec<CompileError>> {
        for node in nodes {
            self.compile_node(node, 0);
        }
        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Halt,
            vec![],
            None,
        ));
        if self.errors.is_empty() {
            Ok(self.bytecode.clone())
        } else {
            Err(self.errors.clone())
        }
    }

    // Compiles a single AST node.
    fn compile_node(&mut self, node: &AstNode, position: usize) {
        match node {
            AstNode::VarDecl {
                is_mutable,
                name,
                type_annot,
                expr,
            } => {
                self.compile_var_decl(*is_mutable, name, type_annot, expr, position);
            }
            AstNode::FnDecl {
                name,
                params,
                return_type,
                body,
            } => {
                self.compile_fn_decl(name, params, return_type, body, position);
            }
            AstNode::If {
                condition,
                then_branch,
                else_branch,
            } => {
                self.compile_if(condition, then_branch, else_branch, position);
            }
            AstNode::Match { expr, arms } => {
                self.compile_match(expr, arms, position);
            }
            AstNode::Expr { kind } => {
                self.compile_expr(kind, position);
            }
            AstNode::MacroDef { name, params, body } => {
                self.compile_macro_def(name, params, body, position);
            }
            AstNode::GenericFunction { name, type_params, args, return_type, body } => {
                self.compile_generic_function(name, type_params, args, return_type, body, position);
            }
            AstNode::GenericStruct { name, type_params, fields } => {
                self.compile_generic_struct(name, type_params, fields, position);
            }
            _ => {
                self.errors.push(CompileError {
                    message: "Unsupported node type".to_string(),
                    position,
                });
            }
        }
    }

    // Compiles a variable declaration.
    fn compile_var_decl(
        &mut self,
        _is_mutable: bool,
        name: &str,
        type_annot: &Option<TypeAnnotation>,
        expr: &AstNode,
        position: usize,
    ) {
        let reg = self.allocate_register(name, position);
        if reg.is_none() {
            return;
        }
        let reg = reg.unwrap();

        let expr_reg = self.compile_expr_to_register(expr, position);
        if expr_reg.is_none() {
            return;
        }
        let expr_reg = expr_reg.unwrap();

        let var_type = if let Some(annot) = type_annot {
            match TypeSystem::parse_type_annotation(&annot_to_string(annot), position) {
                Ok(ty) => {
                    if matches!(ty, Type::Generic { .. }) {
                        // Resolve generic type
                        match ksl_generics::GenericCompiler.substitute_type(&ty, &[]) {
                            Ok(resolved_ty) => resolved_ty,
                            Err(err) => {
                                self.errors.push(CompileError {
                                    message: err,
                                    position,
                                });
                                return;
                            }
                        }
                    } else {
                        ty
                    }
                }
                Err(err) => {
                    self.errors.push(CompileError {
                        message: err.message,
                        position,
                    });
                    return;
                }
            }
        } else {
            TypeSystem::infer_type(expr, &self.ctx, position).unwrap_or(Type::Void)
        };

        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Mov,
            vec![Operand::Register(reg), Operand::Register(expr_reg)],
            Some(var_type.clone()),
        ));

        self.ctx.add_binding(name.to_string(), var_type);
    }

    // Compiles a function declaration.
    fn compile_fn_decl(
        &mut self,
        name: &str,
        params: &[(String, TypeAnnotation)],
        return_type: &TypeAnnotation,
        body: &[AstNode],
        position: usize,
    ) {
        let fn_index = self.bytecode.instructions.len() as u32;
        self.functions.insert(name.to_string(), fn_index);

        let old_registers = self.registers.clone();
        let old_next_register = self.next_register;
        self.registers.clear();
        self.next_register = 0;

        let mut param_types = Vec::new();
        for (param_name, param_type) in params {
            let reg = self.allocate_register(param_name, position);
            if reg.is_none() {
                return;
            }
            let param_ty = match TypeSystem::parse_type_annotation(&annot_to_string(param_type), position) {
                Ok(ty) => ty,
                Err(err) => {
                    self.errors.push(CompileError {
                        message: err.message,
                        position,
                    });
                    return;
                }
            };
            self.ctx.add_binding(param_name.clone(), param_ty.clone());
            param_types.push(param_ty);
        }

        for node in body {
            self.compile_node(node, position);
        }

        let ret_type = TypeSystem::parse_type_annotation(&annot_to_string(return_type), position).unwrap_or(Type::Void);
        if ret_type != Type::Void {
            if let Some(last_node) = body.last() {
                let last_reg = self.compile_expr_to_register(last_node, position);
                if let Some(reg) = last_reg {
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Return,
                        vec![Operand::Register(reg)],
                        Some(ret_type),
                    ));
                }
            }
        } else {
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Return,
                vec![],
                None,
            ));
        }

        self.registers = old_registers;
        self.next_register = old_next_register;
    }

    // Compiles a macro definition.
    fn compile_macro_def(
        &mut self,
        name: &str,
        params: &[(String, TypeAnnotation)],
        body: &[AstNode],
        position: usize,
    ) {
        let macro_params = params.iter().map(|(name, ty)| {
            let param_type = match ty {
                TypeAnnotation::Simple(s) if s == "string" => ksl_macros::ParamType::String,
                TypeAnnotation::Simple(s) if s == "ident" => ksl_macros::ParamType::Ident,
                _ => ksl_macros::ParamType::Expr, // Default to expression
            };
            ksl_macros::MacroParam::new(name, param_type)
        }).collect();
        let macro_def = MacroDef::new(name, macro_params, body.to_vec());
        self.macro_expander.register_macro(macro_def);
    }

    // Compiles a generic function.
    fn compile_generic_function(
        &mut self,
        name: &str,
        type_params: &GenericDef,
        args: &[(String, Type)],
        return_type: &Type,
        body: &[AstNode],
        position: usize,
    ) {
        let fn_index = self.bytecode.instructions.len() as u32;
        self.functions.insert(name.to_string(), fn_index);

        let old_registers = self.registers.clone();
        let old_next_register = self.next_register;
        self.registers.clear();
        self.next_register = 0;

        let mut generic_def = type_params.clone();
        let substitutions = args.iter()
            .filter_map(|(_, ty)| if matches!(ty, Type::Generic { .. }) { Some(ty.clone()) } else { None })
            .collect::<Vec<Type>>();
        if let Err(err) = generic_def.monomorphize(substitutions) {
            self.errors.push(CompileError {
                message: err,
                position,
            });
            return;
        }

        for (param_name, param_type) in args {
            let reg = self.allocate_register(param_name, position);
            if reg.is_none() {
                return;
            }
            self.ctx.add_binding(param_name.clone(), param_type.clone());
        }

        for node in body {
            self.compile_node(node, position);
        }

        let ret_type = return_type.clone();
        if ret_type != Type::Void {
            if let Some(last_node) = body.last() {
                let last_reg = self.compile_expr_to_register(last_node, position);
                if let Some(reg) = last_reg {
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Return,
                        vec![Operand::Register(reg)],
                        Some(ret_type),
                    ));
                }
            }
        } else {
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Return,
                vec![],
                None,
            ));
        }

        self.registers = old_registers;
        self.next_register = old_next_register;
    }

    // Compiles a generic struct.
    fn compile_generic_struct(
        &mut self,
        name: &str,
        type_params: &GenericDef,
        fields: &[(String, Type)],
        position: usize,
    ) {
        let mut generic_def = type_params.clone();
        let substitutions = fields.iter()
            .filter_map(|(_, ty)| if matches!(ty, Type::Generic { .. }) { Some(ty.clone()) } else { None })
            .collect::<Vec<Type>>();
        if let Err(err) = generic_def.monomorphize(substitutions) {
            self.errors.push(CompileError {
                message: err,
                position,
            });
            return;
        }

        let mut struct_type = Type::Struct {
            name: name.to_string(),
            fields: Vec::new(),
        };
        for (field_name, field_type) in fields {
            let concrete_type = match self.generic_compiler.substitute_type(field_type, &generic_def.concrete_types) {
                Ok(ty) => ty,
                Err(err) => {
                    self.errors.push(CompileError {
                        message: err,
                        position,
                    });
                    return;
                }
            };
            if let Type::Struct { fields, .. } = &mut struct_type {
                fields.push((field_name.clone(), concrete_type));
            }
        }

        self.ctx.add_binding(name.to_string(), struct_type);
    }

    // Compiles an if statement.
    fn compile_if(
        &mut self,
        condition: &AstNode,
        then_branch: &[AstNode],
        else_branch: &Option<Vec<AstNode>>,
        position: usize,
    ) {
        let cond_reg = self.compile_expr_to_register(condition, position);
        if cond_reg.is_none() {
            return;
        }
        let cond_reg = cond_reg.unwrap();

        let else_label = self.bytecode.instructions.len() as u32 + 1;
        let end_label = if else_branch.is_some() {
            (self.bytecode.instructions.len() + then_branch.len() + 2) as u32
        } else {
            (self.bytecode.instructions.len() + then_branch.len() + 1) as u32
        };

        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Jump,
            vec![Operand::Immediate((else_label as u32).to_le_bytes().to_vec())],
            None,
        ));

        for node in then_branch {
            self.compile_node(node, position);
        }

        if else_branch.is_some() {
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Jump,
                vec![Operand::Immediate((end_label as u32).to_le_bytes().to_vec())],
                None,
            ));
        }

        if let Some(else_nodes) = else_branch {
            for node in else_nodes {
                self.compile_node(node, position);
            }
        }
    }

    // Compiles a match statement.
    fn compile_match(&mut self, expr: &AstNode, arms: &[(AstNode, Vec<AstNode>)], position: usize) {
        let expr_reg = self.compile_expr_to_register(expr, position);
        if expr_reg.is_none() {
            return;
        }
        let expr_reg = expr_reg.unwrap();

        let mut end_label = self.bytecode.instructions.len() as u32;
        let mut arm_labels: Vec<u32> = Vec::new();

        for (_, body) in arms {
            end_label += (body.len() + 2) as u32;
            arm_labels.push(self.bytecode.instructions.len() as u32 + 1);
        }

        for (i, (pattern, _)) in arms.iter().enumerate() {
            let pattern_reg = self.compile_expr_to_register(pattern, position);
            if pattern_reg.is_none() {
                continue;
            }
            let pattern_reg = pattern_reg.unwrap();

            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Sub,
                vec![
                    Operand::Register(expr_reg),
                    Operand::Register(expr_reg),
                    Operand::Register(pattern_reg),
                ],
                Some(Type::U32),
            ));

            if i < arms.len() - 1 {
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Jump,
                    vec![Operand::Immediate((arm_labels[i + 1] as u32).to_le_bytes().to_vec())],
                    None,
                ));
            }
        }

        for (i, (_, body)) in arms.iter().enumerate() {
            for node in body {
                self.compile_node(node, position);
            }
            if i < arms.len() - 1 {
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Jump,
                    vec![Operand::Immediate((end_label as u32).to_le_bytes().to_vec())],
                    None,
                ));
            }
        }
    }

    /// Compiles an expression to bytecode.
    /// @param kind Expression kind
    /// @param position Source position
    fn compile_expr(&mut self, kind: &ExprKind, position: usize) -> Option<u8> {
        match kind {
            ExprKind::AsyncCall { name, args } => {
                self.compile_async_call(name, args, position)
            }
            ExprKind::Call { name, args } => {
                self.compile_call(name, args, position)
            }
            ExprKind::Number(num) => {
                let reg = self.next_register()?;
                let value = num.parse::<u32>().unwrap_or(0);
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Mov,
                    vec![
                        Operand::Register(reg),
                        Operand::Immediate(value.to_le_bytes().to_vec()),
                    ],
                    Some(Type::U32),
                ));
                Some(reg)
            }
            ExprKind::String(s) => {
                let reg = self.next_register()?;
                let bytes = s.as_bytes().to_vec();
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Mov,
                    vec![
                        Operand::Register(reg),
                        Operand::Immediate(bytes),
                    ],
                    Some(Type::String),
                ));
                Some(reg)
            }
            ExprKind::Ident(name) => {
                self.registers.get(name).copied()
            }
            ExprKind::BinaryOp { op, left, right } => {
                let left_reg = self.compile_expr_to_register(left, position)?;
                let right_reg = self.compile_expr_to_register(right, position)?;
                let result_reg = self.next_register()?;
                let opcode = match op.as_str() {
                    "+" => KapraOpCode::Add,
                    "-" => KapraOpCode::Sub,
                    "*" => KapraOpCode::Mul,
                    _ => {
                        self.errors.push(CompileError {
                            message: format!("Unsupported operator: {}", op),
                            position,
                        });
                        return None;
                    }
                };
                let result_type = TypeSystem::infer_type(kind, &self.ctx, position).unwrap_or(Type::U32);
                self.bytecode.add_instruction(KapraInstruction::new(
                    opcode,
                    vec![
                        Operand::Register(result_reg),
                        Operand::Register(left_reg),
                        Operand::Register(right_reg),
                    ],
                    Some(result_type),
                ));
                Some(result_reg)
            }
            ExprKind::MacroCall { name, args } => {
                let macro_call = ksl_macros::MacroCall::new(name, args.clone());
                let expanded_nodes = match self.macro_expander.expand(&macro_call) {
                    Ok(nodes) => nodes,
                    Err(err) => {
                        self.errors.push(CompileError {
                            message: err,
                            position,
                        });
                        return None;
                    }
                };
                let mut last_reg = None;
                for node in expanded_nodes {
                    last_reg = self.compile_expr_to_register(&node, position);
                }
                last_reg
            }
            _ => {
                self.errors.push(CompileError {
                    message: "Unsupported expression type".to_string(),
                    position,
                });
                None
            }
        }
    }

    /// Compiles an async function call.
    /// @param name Function name
    /// @param args Function arguments
    /// @param position Source position
    /// @returns Register containing the result
    fn compile_async_call(&mut self, name: &str, args: &[AstNode], position: usize) -> Option<u8> {
        let dst_reg = self.next_register()?;

        // Compile arguments
        let mut arg_regs = Vec::new();
        for arg in args {
            let reg = self.compile_expr_to_register(arg, position)?;
            arg_regs.push(reg);
        }

        match name {
            "http.post" => {
                if arg_regs.len() != 2 {
                    self.errors.push(CompileError {
                        message: format!("http.post expects 2 arguments, got {}", arg_regs.len()),
                        position,
                    });
                    return None;
                }
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::HttpPost,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Register(arg_regs[0]), // url
                        Operand::Register(arg_regs[1]), // data
                    ],
                    Some(Type::Result {
                        ok: Box::new(Type::String),
                        err: Box::new(Type::Error),
                    }),
                ));
            }
            "http.get" => {
                if arg_regs.len() != 1 {
                    self.errors.push(CompileError {
                        message: format!("http.get expects 1 argument, got {}", arg_regs.len()),
                        position,
                    });
                    return None;
                }
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::HttpGet,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Register(arg_regs[0]), // url
                    ],
                    Some(Type::Result {
                        ok: Box::new(Type::String),
                        err: Box::new(Type::Error),
                    }),
                ));
            }
            "tcp.connect" => {
                if arg_regs.len() != 2 {
                    self.errors.push(CompileError {
                        message: format!("tcp.connect expects 2 arguments, got {}", arg_regs.len()),
                        position,
                    });
                    return None;
                }
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::TcpConnect,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Register(arg_regs[0]), // host
                        Operand::Register(arg_regs[1]), // port
                    ],
                    Some(Type::Result {
                        ok: Box::new(Type::U32),
                        err: Box::new(Type::Error),
                    }),
                ));
            }
            "udp.send" => {
                if arg_regs.len() != 3 {
                    self.errors.push(CompileError {
                        message: format!("udp.send expects 3 arguments, got {}", arg_regs.len()),
                        position,
                    });
                    return None;
                }
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::UdpSend,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Register(arg_regs[0]), // host
                        Operand::Register(arg_regs[1]), // port
                        Operand::Register(arg_regs[2]), // data
                    ],
                    Some(Type::Result {
                        ok: Box::new(Type::U32),
                        err: Box::new(Type::Error),
                    }),
                ));
            }
            _ => {
                // Handle other async functions
                let fn_index = match self.functions.get(name) {
                    Some(&index) => index,
                    None => {
                        self.errors.push(CompileError {
                            message: format!("Undefined async function: {}", name),
                            position,
                        });
                        return None;
                    }
                };

                // Add async call instruction
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::AsyncCall,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Immediate(fn_index.to_le_bytes().to_vec()),
                    ],
                    Some(Type::Result {
                        ok: Box::new(Type::Void),
                        err: Box::new(Type::Error),
                    }),
                ));

                // Add arguments
                for reg in arg_regs {
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Mov,
                        vec![Operand::Register(reg), Operand::Register(reg)],
                        None,
                    ));
                }
            }
        }

        Some(dst_reg)
    }

    /// Compiles a regular function call.
    /// @param name Function name
    /// @param args Function arguments
    /// @param position Source position
    /// @returns Register containing the result
    fn compile_call(&mut self, name: &str, args: &[AstNode], position: usize) -> Option<u8> {
        let dst_reg = self.next_register()?;

        // Compile arguments
        let mut arg_regs = Vec::new();
        for arg in args {
            let reg = self.compile_expr_to_register(arg, position)?;
            arg_regs.push(reg);
        }

        match name {
            "print" => {
                if arg_regs.len() != 1 {
                    self.errors.push(CompileError {
                        message: format!("print expects 1 argument, got {}", arg_regs.len()),
                        position,
                    });
                    return None;
                }
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Print,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Register(arg_regs[0]), // message
                    ],
                    Some(Type::Void),
                ));
            }
            // ... handle other standard library functions ...
            _ => {
                // Handle regular function calls
                let fn_index = match self.functions.get(name) {
                    Some(&index) => index,
                    None => {
                        self.errors.push(CompileError {
                            message: format!("Undefined function: {}", name),
                            position,
                        });
                        return None;
                    }
                };

                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Call,
                    vec![
                        Operand::Register(dst_reg),
                        Operand::Immediate(fn_index.to_le_bytes().to_vec()),
                    ],
                    None,
                ));

                // Add arguments
                for reg in arg_regs {
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Mov,
                        vec![Operand::Register(reg), Operand::Register(reg)],
                        None,
                    ));
                }
            }
        }

        Some(dst_reg)
    }

    // Compiles an expression and returns the register holding the result.
    fn compile_expr_to_register(&mut self, expr: &AstNode, position: usize) -> Option<u8> {
        match expr {
            AstNode::Expr { kind } => self.compile_expr(kind, position)
        }
    }

    // Allocates a new register for a variable.
    fn allocate_register(&mut self, name: &str, position: usize) -> Option<u8> {
        if self.registers.contains_key(name) {
            self.errors.push(CompileError {
                message: format!("Variable {} already defined", name),
                position,
            });
            return None;
        }
        let reg = self.next_register()?;
        self.registers.insert(name.to_string(), reg);
        Some(reg)
    }

    // Gets the next free register.
    fn next_register(&mut self) -> Option<u8> {
        if self.next_register >= 16 {
            self.errors.push(CompileError {
                message: "No free registers".to_string(),
                position: 0,
            });
            return None;
        }
        let reg = self.next_register;
        self.next_register += 1;
        Some(reg)
    }
}

// Converts TypeAnnotation to string for parsing.
fn annot_to_string(annot: &TypeAnnotation) -> String {
    match annot {
        TypeAnnotation::Simple(s) => s.clone(),
        TypeAnnotation::Array { element, size } => format!("array<{}, {}>", element, size),
    }
}

/// Public API to compile an AST.
/// @param nodes The list of AST nodes to compile.
/// @returns `Ok(KapraBytecode)` if compilation succeeds, or `Err` with compilation errors.
/// @example
/// ```ksl
/// let nodes = vec![AstNode::VarDecl { ... }];
/// let bytecode = compile(&nodes).unwrap();
/// ```
pub fn compile(nodes: &[AstNode]) -> Result<KapraBytecode, Vec<CompileError>> {
    let mut compiler = Compiler::new();
    compiler.compile(nodes)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compile_var_decl() {
        let nodes = vec![
            AstNode::VarDecl {
                is_mutable: true,
                name: "x".to_string(),
                type_annot: Some(TypeAnnotation::Simple("u32".to_string())),
                expr: Box::new(AstNode::Expr {
                    kind: ExprKind::Number("42".to_string()),
                }),
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert_eq!(bytecode.instructions.len(), 3); // Mov (num) + Mov (var) + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[1].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[2].opcode, KapraOpCode::Halt);
    }

    #[test]
    fn compile_macro_def_and_call() {
        let nodes = vec![
            AstNode::MacroDef {
                name: "log".to_string(),
                params: vec![("msg".to_string(), TypeAnnotation::Simple("string".to_string()))],
                body: vec![
                    AstNode::Expr {
                        kind: ExprKind::Call {
                            name: "print".to_string(),
                            args: vec![
                                AstNode::Expr {
                                    kind: ExprKind::Ident("msg".to_string()),
                                },
                            ],
                        },
                    },
                ],
            },
            AstNode::Expr {
                kind: ExprKind::MacroCall {
                    name: "log".to_string(),
                    args: vec![
                        AstNode::Expr {
                            kind: ExprKind::String("Hello".to_string()),
                        },
                    ],
                },
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert!(bytecode.instructions.len() >= 2); // Mov (string) + Halt (print not implemented)
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[0].operands[1], Operand::Immediate(b"Hello".to_vec()));
    }

    #[test]
    fn compile_generic_function() {
        let nodes = vec![
            AstNode::GenericFunction {
                name: "add".to_string(),
                type_params: GenericDef::new(vec![TypeParam::new("T")]),
                args: vec![
                    ("x".to_string(), Type::Generic {
                        name: "T".to_string(),
                        constraints: vec![Type::U32, Type::F32],
                    }),
                    ("y".to_string(), Type::Generic {
                        name: "T".to_string(),
                        constraints: vec![Type::U32, Type::F32],
                    }),
                ],
                return_type: Type::Generic {
                    name: "T".to_string(),
                    constraints: vec![Type::U32, Type::F32],
                },
                body: vec![
                    AstNode::Expr {
                        kind: ExprKind::BinaryOp {
                            op: "+".to_string(),
                            left: Box::new(AstNode::Expr {
                                kind: ExprKind::Ident("x".to_string()),
                            }),
                            right: Box::new(AstNode::Expr {
                                kind: ExprKind::Ident("y".to_string()),
                            }),
                        },
                    },
                ],
            },
            AstNode::VarDecl {
                is_mutable: true,
                name: "x".to_string(),
                type_annot: Some(TypeAnnotation::Simple("u32".to_string())),
                expr: Box::new(AstNode::Expr {
                    kind: ExprKind::Call {
                        name: "add".to_string(),
                        args: vec![
                            AstNode::Expr {
                                kind: ExprKind::Number("1".to_string()),
                            },
                            AstNode::Expr {
                                kind: ExprKind::Number("2".to_string()),
                            },
                        ],
                    },
                }),
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert!(bytecode.instructions.len() >= 5); // Add + Return + Mov (args) + Mov (var) + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Add);
        assert_eq!(bytecode.instructions[1].opcode, KapraOpCode::Return);
    }

    #[test]
    fn test_compile_http_post() {
        let mut compiler = Compiler::new();
        
        let expr = ExprKind::AsyncCall {
            name: "http.post".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("https://api.example.com".to_string()),
                },
                AstNode::Expr {
                    kind: ExprKind::String("{\"data\": 123}".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert_eq!(bytecode.instructions.len(), 1);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::HttpPost);
        assert_eq!(bytecode.instructions[0].operands.len(), 3);
    }

    #[test]
    fn test_compile_http_get() {
        let mut compiler = Compiler::new();
        
        let expr = ExprKind::AsyncCall {
            name: "http.get".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("https://api.example.com".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert_eq!(bytecode.instructions.len(), 1);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::HttpGet);
        assert_eq!(bytecode.instructions[0].operands.len(), 2);
    }

    #[test]
    fn test_compile_tcp_connect() {
        let mut compiler = Compiler::new();
        
        let expr = ExprKind::AsyncCall {
            name: "tcp.connect".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("localhost".to_string()),
                },
                AstNode::Expr {
                    kind: ExprKind::Number("8080".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert_eq!(bytecode.instructions.len(), 1);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::TcpConnect);
        assert_eq!(bytecode.instructions[0].operands.len(), 3);
    }

    #[test]
    fn test_compile_udp_send() {
        let mut compiler = Compiler::new();
        
        let expr = ExprKind::AsyncCall {
            name: "udp.send".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("localhost".to_string()),
                },
                AstNode::Expr {
                    kind: ExprKind::Number("8080".to_string()),
                },
                AstNode::Expr {
                    kind: ExprKind::String("Hello".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert_eq!(bytecode.instructions.len(), 1);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::UdpSend);
        assert_eq!(bytecode.instructions[0].operands.len(), 4);
    }

    #[test]
    fn test_compile_print() {
        let mut compiler = Compiler::new();
        
        let expr = ExprKind::Call {
            name: "print".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("Hello, world!".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert_eq!(bytecode.instructions.len(), 1);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Print);
        assert_eq!(bytecode.instructions[0].operands.len(), 2);
    }

    #[test]
    fn test_compile_async_function() {
        let mut compiler = Compiler::new();
        compiler.functions.insert("fetch_data".to_string(), 0);
        
        let expr = ExprKind::AsyncCall {
            name: "fetch_data".to_string(),
            args: vec![
                AstNode::Expr {
                    kind: ExprKind::String("https://api.example.com".to_string()),
                },
            ],
        };

        let result = compiler.compile_expr(&expr, 0);
        assert!(result.is_some());

        let bytecode = compiler.bytecode;
        assert!(bytecode.instructions.len() >= 2);
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::AsyncCall);
    }
}
