// ksl_compiler.rs
// Compiles type-checked KSL AST into KapraBytecode 2.0.

use crate::ksl_parser::{AstNode, ExprKind, TypeAnnotation};
use crate::ksl_types::{Type, TypeContext, TypeError, TypeSystem};
use crate::ksl_bytecode::{KapraBytecode, KapraInstruction, KapraOpCode, Operand};
use crate::ksl_stdlib::StdLib;
use crate::ksl_stdlib_crypto::CryptoStdLib;
use std::collections::HashMap;

// Compilation error type
#[derive(Debug, PartialEq)]
pub struct CompileError {
    pub message: String,
    pub position: usize,
}

// Compiler state
pub struct Compiler {
    bytecode: KapraBytecode, // Generated bytecode
    registers: HashMap<String, u8>, // Variable name to register mapping
    next_register: u8, // Next free register (0â€“15)
    functions: HashMap<String, u32>, // Function name to instruction index
    labels: Vec<u32>, // Jump labels for control flow
    ctx: TypeContext, // Type context for type-safe codegen
    stdlib: StdLib, // Standard library functions
    crypto_stdlib: CryptoStdLib, // Cryptographic standard library functions
    errors: Vec<CompileError>, // Collect compilation errors
}

impl Compiler {
    pub fn new() -> Self {
        Compiler {
            bytecode: KapraBytecode::new(),
            registers: HashMap::new(),
            next_register: 0,
            functions: HashMap::new(),
            labels: Vec::new(),
            ctx: TypeContext::new(),
            stdlib: StdLib::new(),
            crypto_stdlib: CryptoStdLib::new(),
            errors: Vec::new(),
        }
    }

    // Main entry point: Compile an AST into bytecode
    pub fn compile(&mut self, nodes: &[AstNode]) -> Result<KapraBytecode, Vec<CompileError>> {
        for node in nodes {
            self.compile_node(node, 0);
        }
        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Halt,
            vec![],
            None,
        ));
        if self.errors.is_empty() {
            Ok(self.bytecode.clone())
        } else {
            Err(self.errors.clone())
        }
    }

    // Compile a single AST node
    fn compile_node(&mut self, node: &AstNode, position: usize) {
        match node {
            AstNode::VarDecl {
                is_mutable,
                name,
                type_annot,
                expr,
            } => {
                self.compile_var_decl(*is_mutable, name, type_annot, expr, position);
            }
            AstNode::FnDecl {
                name,
                params,
                return_type,
                body,
            } => {
                self.compile_fn_decl(name, params, return_type, body, position);
            }
            AstNode::If {
                condition,
                then_branch,
                else_branch,
            } => {
                self.compile_if(condition, then_branch, else_branch, position);
            }
            AstNode::Match { expr, arms } => {
                self.compile_match(expr, arms, position);
            }
            AstNode::Expr { kind } => {
                self.compile_expr(kind, position);
            }
        }
    }

    // Compile variable declaration
    fn compile_var_decl(
        &mut self,
        _is_mutable: bool,
        name: &str,
        type_annot: &Option<TypeAnnotation>,
        expr: &AstNode,
        position: usize,
    ) {
        // Allocate a register for the variable
        let reg = self.allocate_register(name, position);
        if reg.is_none() {
            return;
        }
        let reg = reg.unwrap();

        // Compile the expression
        let expr_reg = self.compile_expr_to_register(expr, position);
        if expr_reg.is_none() {
            return;
        }
        let expr_reg = expr_reg.unwrap();

        // Move expression result to variable's register
        let var_type = TypeSystem::infer_type(expr, &self.ctx, position).unwrap_or(Type::Void);
        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Mov,
            vec![Operand::Register(reg), Operand::Register(expr_reg)],
            Some(var_type.clone()),
        ));

        // Update type context
        self.ctx.add_binding(name.to_string(), var_type);
    }

    // Compile function declaration
    fn compile_fn_decl(
        &mut self,
        name: &str,
        params: &[(String, TypeAnnotation)],
        return_type: &TypeAnnotation,
        body: &[AstNode],
        position: usize,
    ) {
        // Record function start
        let fn_index = self.bytecode.instructions.len() as u32;
        self.functions.insert(name.to_string(), fn_index);

        // Save current state
        let old_registers = self.registers.clone();
        let old_next_register = self.next_register;
        self.registers.clear();
        self.next_register = 0;

        // Add parameters to registers and context
        for (param_name, param_type) in params {
            let reg = self.allocate_register(param_name, position);
            if reg.is_none() {
                return;
            }
            let param_ty = match TypeSystem::parse_type_annotation(param_type, position) {
                Ok(ty) => ty,
                Err(err) => {
                    self.errors.push(CompileError {
                        message: err.message,
                        position,
                    });
                    return;
                }
            };
            self.ctx.add_binding(param_name.clone(), param_ty);
        }

        // Compile body
        for node in body {
            self.compile_node(node, position);
        }

        // Add implicit return if needed
        let ret_type = TypeSystem::parse_type_annotation(return_type, position).unwrap_or(Type::Void);
        if ret_type != Type::Void {
            if let Some(last_node) = body.last() {
                let last_reg = self.compile_expr_to_register(last_node, position);
                if let Some(reg) = last_reg {
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Return,
                        vec![Operand::Register(reg)],
                        Some(ret_type),
                    ));
                }
            }
        } else {
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Return,
                vec![],
                None,
            ));
        }

        // Restore state
        self.registers = old_registers;
        self.next_register = old_next_register;
    }

    // Compile if statement
    fn compile_if(
        &mut self,
        condition: &AstNode,
        then_branch: &[AstNode],
        else_branch: &Option<Vec<AstNode>>,
        position: usize,
    ) {
        // Compile condition
        let cond_reg = self.compile_expr_to_register(condition, position);
        if cond_reg.is_none() {
            return;
        }
        let cond_reg = cond_reg.unwrap();

        // Create labels for jumps
        let else_label = self.bytecode.instructions.len() as u32 + 1;
        let end_label = if else_branch.is_some() {
            (self.bytecode.instructions.len() + then_branch.len() + 2) as u32
        } else {
            (self.bytecode.instructions.len() + then_branch.len() + 1) as u32
        };

        // Jump to else/end if condition is false
        self.bytecode.add_instruction(KapraInstruction::new(
            KapraOpCode::Jump,
            vec![Operand::Immediate((else_label as u32).to_le_bytes().to_vec())],
            None,
        ));

        // Compile then branch
        for node in then_branch {
            self.compile_node(node, position);
        }

        // Jump to end if else branch exists
        if else_branch.is_some() {
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Jump,
                vec![Operand::Immediate((end_label as u32).to_le_bytes().to_vec())],
                None,
            ));
        }

        // Compile else branch
        if let Some(else_nodes) = else_branch {
            for node in else_nodes {
                self.compile_node(node, position);
            }
        }
    }

    // Compile match statement
    fn compile_match(&mut self, expr: &AstNode, arms: &[(AstNode, Vec<AstNode>)], position: usize) {
        // Compile expression
        let expr_reg = self.compile_expr_to_register(expr, position);
        if expr_reg.is_none() {
            return;
        }
        let expr_reg = expr_reg.unwrap();

        let mut end_label = self.bytecode.instructions.len() as u32;
        let mut arm_labels: Vec<u32> = Vec::new();

        // Calculate labels for each arm
        for (_, body) in arms {
            end_label += (body.len() + 2) as u32; // +2 for comparison and jump
            arm_labels.push(self.bytecode.instructions.len() as u32 + 1);
        }

        // Generate comparisons and jumps
        for (i, (pattern, _)) in arms.iter().enumerate() {
            let pattern_reg = self.compile_expr_to_register(pattern, position);
            if pattern_reg.is_none() {
                continue;
            }
            let pattern_reg = pattern_reg.unwrap();

            // Compare expr_reg with pattern_reg (simplified: assume equality check)
            self.bytecode.add_instruction(KapraInstruction::new(
                KapraOpCode::Sub,
                vec![
                    Operand::Register(expr_reg),
                    Operand::Register(expr_reg),
                    Operand::Register(pattern_reg),
                ],
                Some(Type::U32),
            ));

            // Jump to next arm if not equal
            if i < arms.len() - 1 {
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Jump,
                    vec![Operand::Immediate((arm_labels[i + 1] as u32).to_le_bytes().to_vec())],
                    None,
                ));
            }
        }

        // Compile arm bodies
        for (i, (_, body)) in arms.iter().enumerate() {
            for node in body {
                self.compile_node(node, position);
            }
            // Jump to end after each arm (except last, if exhaustive)
            if i < arms.len() - 1 {
                self.bytecode.add_instruction(KapraInstruction::new(
                    KapraOpCode::Jump,
                    vec![Operand::Immediate((end_label as u32).to_le_bytes().to_vec())],
                    None,
                ));
            }
        }
    }

    // Compile expression and return the register holding the result
    fn compile_expr_to_register(&mut self, expr: &AstNode, position: usize) -> Option<u8> {
        match expr {
            AstNode::Expr { kind } => match kind {
                ExprKind::Number(num) => {
                    let reg = self.next_register()?;
                    let value = num.parse::<u32>().unwrap_or(0); // Simplified: u32 only
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Mov,
                        vec![
                            Operand::Register(reg),
                            Operand::Immediate(value.to_le_bytes().to_vec()),
                        ],
                        Some(Type::U32),
                    ));
                    Some(reg)
                }
                ExprKind::String(s) => {
                    let reg = self.next_register()?;
                    let bytes = s.as_bytes().to_vec();
                    self.bytecode.add_instruction(KapraInstruction::new(
                        KapraOpCode::Mov,
                        vec![
                            Operand::Register(reg),
                            Operand::Immediate(bytes),
                        ],
                        Some(Type::String),
                    ));
                    Some(reg)
                }
                ExprKind::Ident(name) => {
                    self.registers.get(name).copied()
                }
                ExprKind::BinaryOp { op, left, right } => {
                    let left_reg = self.compile_expr_to_register(left, position)?;
                    let right_reg = self.compile_expr_to_register(right, position)?;
                    let result_reg = self.next_register()?;
                    let opcode = match op.as_str() {
                        "+" => KapraOpCode::Add,
                        "-" => KapraOpCode::Sub,
                        "*" => KapraOpCode::Mul,
                        _ => {
                            self.errors.push(CompileError {
                                message: format!("Unsupported operator: {}", op),
                                position,
                            });
                            return None;
                        }
                    };
                    let result_type = TypeSystem::infer_type(expr, &self.ctx, position).unwrap_or(Type::U32);
                    self.bytecode.add_instruction(KapraInstruction::new(
                        opcode,
                        vec![
                            Operand::Register(result_reg),
                            Operand::Register(left_reg),
                            Operand::Register(right_reg),
                        ],
                        Some(result_type),
                    ));
                    Some(result_reg)
                }
                ExprKind::Call { name, args } => {
                    let arg_regs: Vec<u8> = args.iter()
                        .map(|arg| self.compile_expr_to_register(arg, position))
                        .collect::<Option<Vec<_>>>()?;
                    let result_reg = self.next_register()?;
                    let instructions = if let Ok(insts) = self.stdlib.emit_call(name, &arg_regs, result_reg) {
                        insts
                    } else if let Ok(insts) = self.crypto_stdlib.emit_call(name, &arg_regs, result_reg) {
                        insts
                    } else {
                        self.errors.push(CompileError {
                            message: format!("Undefined function: {}", name),
                            position,
                        });
                        return None;
                    };
                    for inst in instructions {
                        self.bytecode.add_instruction(inst);
                    }
                    Some(result_reg)
                }
            },
            _ => {
                self.errors.push(CompileError {
                    message: "Unsupported expression".to_string(),
                    position,
                });
                None
            }
        }
    }

    // Compile expression (for statements)
    fn compile_expr(&mut self, kind: &ExprKind, position: usize) {
        self.compile_expr_to_register(&AstNode::Expr { kind: kind.clone() }, position);
    }

    // Allocate a new register for a variable
    fn allocate_register(&mut self, name: &str, position: usize) -> Option<u8> {
        if self.registers.contains_key(name) {
            self.errors.push(CompileError {
                message: format!("Variable {} already defined", name),
                position,
            });
            return None;
        }
        let reg = self.next_register()?;
        self.registers.insert(name.to_string(), reg);
        Some(reg)
    }

    // Get the next free register
    fn next_register(&mut self) -> Option<u8> {
        if self.next_register >= 16 {
            self.errors.push(CompileError {
                message: "No free registers".to_string(),
                position: 0,
            });
            return None;
        }
        let reg = self.next_register;
        self.next_register += 1;
        Some(reg)
    }
}

// Public API to compile an AST
pub fn compile(nodes: &[AstNode]) -> Result<KapraBytecode, Vec<CompileError>> {
    let mut compiler = Compiler::new();
    compiler.compile(nodes)
}

// Assume ksl_parser.rs, ksl_types.rs, ksl_bytecode.rs, ksl_stdlib.rs, and ksl_stdlib_crypto.rs are in the same crate
mod ksl_parser {
    pub use super::{AstNode, ExprKind, TypeAnnotation};
}

mod ksl_types {
    pub use super::{Type, TypeContext, TypeError, TypeSystem};
}

mod ksl_bytecode {
    pub use super::{KapraBytecode, KapraInstruction, KapraOpCode, Operand};
}

mod ksl_stdlib {
    pub use super::StdLib;
}

mod ksl_stdlib_crypto {
    pub use super::CryptoStdLib;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compile_var_decl() {
        let nodes = vec![
            AstNode::VarDecl {
                is_mutable: true,
                name: "x".to_string(),
                type_annot: Some(TypeAnnotation::Simple("u32".to_string())),
                expr: Box::new(AstNode::Expr {
                    kind: ExprKind::Number("42".to_string()),
                }),
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert_eq!(bytecode.instructions.len(), 2); // Mov + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[0].operands[0], Operand::Register(0));
        assert_eq!(bytecode.instructions[0].type_info, Some(Type::U32));
    }

    #[test]
    fn compile_var_decl_array() {
        let nodes = vec![
            AstNode::VarDecl {
                is_mutable: true,
                name: "msg".to_string(),
                type_annot: Some(TypeAnnotation::Array {
                    element: "u8".to_string(),
                    size: 32,
                }),
                expr: Box::new(AstNode::Expr {
                    kind: ExprKind::String("data".to_string()),
                }),
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert_eq!(bytecode.instructions.len(), 2); // Mov + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[0].operands[0], Operand::Register(0));
        assert_eq!(bytecode.instructions[0].type_info, Some(Type::String)); // Infers string type
    }

    #[test]
    fn compile_fn_decl() {
        let nodes = vec![
            AstNode::FnDecl {
                name: "add".to_string(),
                params: vec![
                    ("x".to_string(), TypeAnnotation::Simple("u32".to_string())),
                    ("y".to_string(), TypeAnnotation::Simple("u32".to_string())),
                ],
                return_type: TypeAnnotation::Simple("u32".to_string()),
                body: vec![
                    AstNode::Expr {
                        kind: ExprKind::BinaryOp {
                            op: "+".to_string(),
                            left: Box::new(AstNode::Expr {
                                kind: ExprKind::Ident("x".to_string()),
                            }),
                            right: Box::new(AstNode::Expr {
                                kind: ExprKind::Ident("y".to_string()),
                            }),
                        },
                    },
                ],
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert!(bytecode.instructions.len() >= 3); // Add + Return + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Add);
        assert_eq!(bytecode.instructions[1].opcode, KapraOpCode::Return);
        assert_eq!(bytecode.instructions[2].opcode, KapraOpCode::Halt);
    }

    #[test]
    fn compile_fn_call() {
        let nodes = vec![
            AstNode::Expr {
                kind: ExprKind::Call {
                    name: "sha3".to_string(),
                    args: vec![
                        AstNode::Expr {
                            kind: ExprKind::String("data".to_string()),
                        },
                    ],
                },
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert!(bytecode.instructions.len() >= 3); // Mov (string) + Sha3 + Halt
        assert_eq!(bytecode.instructions[0].opcode, KapraOpCode::Mov);
        assert_eq!(bytecode.instructions[1].opcode, KapraOpCode::Sha3);
        assert_eq!(bytecode.instructions[2].opcode, KapraOpCode::Halt);
    }

    #[test]
    fn compile_if() {
        let nodes = vec![
            AstNode::If {
                condition: Box::new(AstNode::Expr {
                    kind: ExprKind::BinaryOp {
                        op: ">".to_string(),
                        left: Box::new(AstNode::Expr {
                            kind: ExprKind::Number("42".to_string()),
                        }),
                        right: Box::new(AstNode::Expr {
                            kind: ExprKind::Number("0".to_string()),
                        }),
                    },
                }),
                then_branch: vec![
                    AstNode::VarDecl {
                        is_mutable: true,
                        name: "y".to_string(),
                        type_annot: Some(TypeAnnotation::Simple("u32".to_string())),
                        expr: Box::new(AstNode::Expr {
                            kind: ExprKind::Number("1".to_string()),
                        }),
                    },
                ],
                else_branch: Some(vec![
                    AstNode::VarDecl {
                        is_mutable: true,
                        name: "y".to_string(),
                        type_annot: Some(TypeAnnotation::Simple("u32".to_string())),
                        expr: Box::new(AstNode::Expr {
                            kind: ExprKind::Number("2".to_string()),
                        }),
                    },
                ]),
            },
        ];
        let bytecode = compile(&nodes).unwrap();
        assert!(bytecode.instructions.len() >= 6); // Condition + Jump + Then + Jump + Else + Halt
        assert_eq!(bytecode.instructions[2].opcode, KapraOpCode::Jump); // Conditional jump
        assert_eq!(bytecode.instructions[4].opcode, KapraOpCode::Jump); // End of then branch
    }
}